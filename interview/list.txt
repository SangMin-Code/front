1. 브라우저의 렌더링 과정
    브라우저가 html, css 텍스트 파일을 받아 화면을 그려주는 일련의 과정을 의미하며
    브라우저마다 다른 렌더링 엔진을 사용하기 때문에 같은 소스라도 같은 화면이 그려지지 않을 수 있다.
    렌더링 과정은 다음과 같다.
    1. html, css의 텍스트를 파싱하여 DOM(Document Object Tree), CSSOM (CSS Object Tree)를 구축
    2. 구축된 DOM, CSSOM을 서로 연결하여 실제로 화면에 그려질 렌더 트리를 구축
    3. Layout에 렌더트리의 노드들의 위치와 크기를 계산 하여 렌드 트리를 배치
    4. 실제 화면에 렌더트리를 그리기(paint)

    모든 HTML과 CSS가 parsing 된 후 각 단계를 거치는 것이 아니라 parsing된 것부터
    다음 단계를 진행하는 방식을 렌더링 엔진이 제공하기 때문에 사용자가 화면을 빠르게 볼 수 있다.

    *렌더링 최적화
     렌더링은 화면이 바뀔때 reflow, repaint 과정을 거치는데 노드들의 위치나 크기가 변하지 않으면
     reflow 없이 repaint만으로 바뀐 화면을 그린다. 이때 reflow에는 많은 resoruce가 필요하므로
     최적화를 위해서는 reflow가 일어나지 않는 속성값을 사용하여 화면에 변화를 주는 것이 최적화에 효과적이다.
     reflow가 일어나지 않는 속성의 목록은 다음에서 확인 할 수 있다.
     https://csstriggers.com/   

    * 자바스크립트 엔진? 렌더링 엔진?
      자바스크립트 엔진은 자바스크립트 코드를 분석하여 실행하는 엔진
      렌더링 엔진은 브라우저에 요청된 콘텐츠를 표시하는 엔진
인용
https://d2.naver.com/helloworld/59361


2. http, https 통신의 차이?
데이터 암호화의 차이를 가지고 있으며 https는 네트워크 상에서
중간에 제 3자가 정보를 볼 수 없도록 공개키 암호화를 지원한다.

* 공개키/개인키 암호화
 공개키로 암호화를 하면 개인키로만 복호화가 가능하고
 개인키로 암호화하면 공개키로만 복호화할수 있다.    

* HTTPS 동작과정
 인증된 기관(Certificate Authority)에 공개키를 전송하여 인증서를 발급받아 사용.
1. A기업은 HTTP 기반의 애플리케이션에 HTTPS를 적용하기 위해 공개키/개인키를 발급함
2. CA 기업에게 돈을 지불하고, 공개키를 저장하는 인증서의 발급을 요청함
3. CA 기업은 CA기업의 이름, 서버의 공개키, 서버의 정보 등을 기반으로 인증서를 생성하고, CA 기업의 개인키로 암호화하여 A기업에게 이를 제공함
4. A기업은 클라이언트에게 암호화된 인증서를 제공함
5. 브라우저는 CA기업의 공개키를 미리 다운받아 갖고 있어, 암호화된 인증서를 복호화함
6. 암호화된 인증서를 복호화하여 얻은 A기업의 공개키로 데이터를 암호화하여 요청을 전송함
7. 암호화된 인증서는 CA의 개인키로 암호화되었기 때문에, 신뢰성을 확보할 수 있고, 클라이언트는 A 기업의 공개키로 데이터를 암호화하였기 때문에 A기업만 복호화하여 원본의 데이터를 얻을 수 있다.


출처: https://mangkyu.tistory.com/98 [MangKyu's Diary]

3. OOP의 특징?
 객체지향프로그래밍으로 객체의 관점에서 프로그래밍을 하는 것을 의미한다.
 1. 캡슐화
    - 하나의 객체에 대해 그 객체가 특정한 목적을 위해 필요한 변수나 메소드를 하나로 묶는것
    - 정보은닉을 통해 객체의 데이터를 메서드를 통해서만 변경 가능하도록 함
 2. 상속
    - 부모 클래스의 기능을 자식클래스가 사용
 3. 다형성
    - 상속을 통해 기능을 확장, 변경 - 형태가 같지만 다른 기능을 하는 것
    - Overriding: 상속하여 재정의, Overloading : 다른 파라미터를 사용하여 같은이름의 다른 메서드
 4. 추상화
    - 목적과 관련없느 부분을 제거하여 필요한 부분만을 표현하기 위한 개념
    - 객체들의 공통된 특징을 파악해 정의해놓는 것

4. 함수형 프로그래밍
    명령형 프로그래밍 기반으로 개발한 프로그램들이 프로그램의 크기가 커짐에 따라
    코드의 유지보수가 어려워지자 이를 해결하기 위해 나타난 패러다임.
    함수형 프로그래밍은 거의 모든 것을 순수함수로 나누어 문제를 해결하는 기법으로 작은 문제를 해결하기 위한
    함수를 작성하여 가독성을 높이고 유지보수를 용이하기 해준다.
    대입문을 사용하지 않는 프로그래밍.

    -> 부수효과가 없는 순수함수를 1급 객체로 간주하여 파라미터로 넘기거나 반환값으로 사용할 수 있으며,
       참조 투명성을 지킬 수 있다.

    - 부수효과: 변수의값, 자료구조를 수정, 객체의 필드값 설정, 예외나 오류료 실행 중단, 콘솔또는 파일  I/O 발생
    - 순수함수 : 메모리, I/O 관점에서 부수효과가 없고 함수 실행이 외부 영향을 끼치지 않는 함수
    - 1급객체 : 변수나 데이터 구조 안에 담을 수 있고 파라미터로 전달 가능, 반환값으로 사용 가능, 고유한 구별 가능
    - 참조투명성 : 동일한 인자에 대해 항상 동일한 결과 반환, 기존의 값은 변경되지 않고 유지

인용: https://mangkyu.tistory.com/111


5. 웹 프로토콜
    1. 웹 프로토콜이란?
        웹에서 쓰이는 통신규약
    2. HTTP 통신이란?
        Hyper Text Transfer Protocol브라우저가 웹 서버와 통신하기 위해 사용하는 주요 프로토콜
        요청과 응답으로 이루어짐
    3. HTTP1.1 과 2.0의 차이?
        2.0은 여러 리소스를 한번에 받을 수 있고 압축해서 전송받으므로 1.1보다 빠르다.

6. 비동기 프로그래밍
    1. AJAX
        자바스크립트를 이용하여 비동기적으로 서버와 클라이언트가 통신하는 방식
        일반적으로 서버에게 웹페이지를 받아오면 전체 화면을 갱신하지만 AJAX를 이용하면
        필요한 데이터만 HTML, TXT, XML, JSON 형식으로 받아올 수 있다.
    2. Promise 와 CallBack의 차이점, 각각의 장단점 설명
        - CallBack :
            비동기 적으로 호출하는 함수로 어떤 이벤트가 발생하거나 특정 시점에 도달했을 때
            시스템에서 호출하는 함수를 말한다. 특정한 문법적 특징을 가진것이 아니라 호출방식에 의한 구분이다.
            장점- > 비동기적이므로 특정 이벤트가 발생했을 때 원하는 함수를 호출 가능하다.

            비동기 함수로 어떤 함수의 처리 이후 실행되는 함수 
            문법적으로 CallBack에서 return에 대한 처리가 단계적으로 깊어질 수록
            반복된 CallBack함수를 적어야 하므로 알아보기 힘들어지는 단점이 있다.
            이를 해결하기 위해 Proise가 등장.
        - Promise :
            비동기처리에 사용되는 객체로 Callback이 여러개가 중첩될 경우를 극복하기 위한 패턴
            비동기 작업들의 순차적 진행, 병렬적 진행의 컨트롤이 쉬우지고 코드의 가독성을 확보할 수 있다.
    3. Async, Await
        비동기처리를 동기적으로 처리하는 것처럼 보일 수 있는 문법.
        코드가 동기적인 코드 흐름으로 개발이 가능하다.

7. 자바스크립트의 타입
    1. 자바스크립트의 Number Type은 다른 언어들과의 차이점은? 왜 하나만 존재하는지?
        - java의 경우 int, double, float등이 있지만 자바스크립트에는 number로 실수를 지원하므로 하나로 모두 해결가능하다

    2. 자바스크립트의 원시 타입의 종류는?
        - boolean, string, number, udefined, null, symbol 6종류
        - undefined는 선언은 되어있으나 값이 없는 상태 null은 obj이며 빈 값을 의미하며


8. 실행 컨텍스트(Excution Context)
    1. 실행 컨텍스트?
        - 자바스크립트들의 코드들이 실행되기 위한 환경
          전역 컨텍스트, 함수 컨텍스트 2가지로 나뉨
          전역 컨텍스트가 하나 생성 후에 함수가 호출될 때마다 함수 컨텍스트가 생성
          컨텍스트 생성시 변수객체, 스코프체인, this가 생성
          컨텍스트 생성 후 함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 
          스코프체인을 따라 올라가며 찾는다.
          함수 실행이 끝나면 해당 컨텍스트가 사라지고 페이지가 종료 시 전역 컨텍스트 사라짐.
          자바스크립트 코드가 실행되기 위해 필요한 변수객체, 스코프체인, this 정보를 담고 있는 곳을 실행컨텍스트라 함
    2. 자바스크립트의 호이스팅
        - 변수를 선언하고 초기화했을 때 선언부분이 최상단으로 끌어올려지는 현상
    
    3. 클로저(Closure)란? 사용 이유?
        - 반환된 내부함수가 잔신이 선언됐을 때의 환경인 스코프를 기억하여
          자신이 선언됐을 때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수
          자신이 생성될 때의 환경을 기억하는 함수.
          1. 현재 상태를 기억하고 변경된 최신 상태를 유지
          2. 전역 변수의 사용을 억제
          3. 정보 은닉
9. 가비지 컬렉터의 역할과 동작
        메모리 할당을 추적하고 필요하지 않은 영역을 판단하여 회수
        참조 값을 생성하고 더 이상 참조할 것이 없거나 비어졌을 때 동작하여 메모리를 반환한다.

10. 자바스크립트의 순환참조와 문제, 해결방법
        서로 순환되면서 참조되어질 경우 가비지컬렉터가 작동하지 않고 메모리 누수가 발생한다.
        null을 할당하여 연결을 끊는 방법을 사용하여 해결.
        대부분의 브라우저에서는 mark and sweep알고리즘을 사용하여 가비지컬렉터가
        참조되지 않는 객체가 있을 때 동작하는 것이 아니라 접근할 수 없는 객체일때 동작한다.

11. 자바스크립트의 배열이 실제 자료구조 배열이 아닌데 그 이유는?
        자바스크립트 배열은 해시 테이블로 구현된 객체이므로 특정 요소를 탐색하거나
        요소를 삽입 또는 삭제하는 경우 빠른 성능을 기대할 수 있다. 
     

12. 이벤트 루프? 동시성 모델
        자바스크립트는 싱글 스레드 기반 언어로 함수를 실행하면 호출된 함수가
        스택에 순차적으로 쌓이고 스택의 맨 위에서부터 하나씩 처리된다. 
        자바스크립트는 이벤트 루프를 통해 동시에 처리되는 것처럼 보이게 하는 동시성을 지원하는데
        이벤트 루프는 콜 스택에 실행중인 함수가 있는지 확인하고 콜백 함수들을 모아놓은 이벤트 큐에 있는
        함수들을 콜 스택이 비어있을 때 이동시켜 실행시킨다.

13. 프로토 타입?
        자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거하였다.
        생성자 함수가 생성할 모든 인스턴스가 공통적을 ㅗ사용할 프로퍼티나 메소드를 프로토타입에 구현해놓고
        이를 상속하여 사용한다.

    __proto__ 접근자 프로퍼티 : 자신의 프로토타입 내부슬롯에 접근
    프로토타입 체인 : 객체의 프로퍼티에 접근하려고 할 때 객체에 접근하려는 프로퍼티가 없으면
                    __proto__ 접근자 프로퍼티가 가리키는 링크를 따라 부모욕할을 하는 프로토타입의 프로퍼티를 검색
                    최상위는 Object.prototype
    prototype property : 생성자 함수가 생성할 인스턴스의 프로토타입

14. this
    1. This ?
        자바스크립트의 내부함수는 일반함수,메소드,콜백함수 어디에서 선언되었든지 this는 전역객체를 가르킴
        일반함수의 this는 window(전역)을 가리키며 arrow function의 this는 언제나 상위스코프의 this를 가르킴
    2. Call, Apply, Bind
        this를 바인딩하기 위한 방법
        Call은 this를 바인딩하면서 함수 호출 두번째 인자가 하나
        Apply는 this를 바인딩하면허 함수 호출 두번째 인자가 배열
        Bind는 함수를 호출하는 것이 아닌 This 가 바인디 된 새로운 함수 리턴

    3. use strict모드에서의 this
        일반함수에서의 this는 undefined가 바인딩

15. ES6
    1. Es6 스펙에 대한 지원이 안될때의 해결방법
        - Babel 사용 Es5이하의 문법으로 변환
        Babel?
        - 트랜스파일러
    2. Es6에서 추가된 스펙
        let, const, arrowfunction, class, promise...
        var, let,const의 차이점?
        - var: 유연한 변수 선언으로 재선언, 재할당이 가능하므로 사용않는 것을 추천
        - const : 재할당 불가능한 변수
        - let : 재할당 가능한 변수

16. Class 
    자바스크립트도 클래스가 구현 가능하지만
    클래스는 자바스크립트의 프로토타입 기반 패턴의 syntactic sugar이다.



17. 타입스크립트?
    Javscript의 동적타입 언어의 약점을 보완하기 위해 타입을 지정해주는 것
    메모리 절약, 코드의 가독성에 도움

18. 라이브러리와 프레임워크

19. 메소드 체이닝

20. 메모라이제이션

21 Restful API

22. CORS

23. Eslint

24. Prettier

25. Webpack

26. NPM, Yarn

27. 적응형과 반응형

28. 프로세스와 스레드의 차이

29. CSR과 SSR의 차이

30. 이벤트 위임

31. DOM을 건드리는 방식과 아닌 방식들의 차이

32. 반응형 프로그래밍

33. Call by Value , Call by ref

34. null, undefined

35. inline, inline block

36. vue, React

37. 