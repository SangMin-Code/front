1. 브라우저의 렌더링 과정
    브라우저가 html, css 텍스트 파일을 받아 화면을 그려주는 일련의 과정을 의미하며
    브라우저마다 다른 렌더링 엔진을 사용하기 때문에 같은 소스라도 같은 화면이 그려지지 않을 수 있다.
    렌더링 과정은 다음과 같다.
    1. html, css의 텍스트를 파싱하여 DOM(Document Object Tree), CSSOM (CSS Object Tree)를 구축
    2. 구축된 DOM, CSSOM을 서로 연결하여 실제로 화면에 그려질 렌더 트리를 구축
    3. Layout에 렌더트리의 노드들의 위치와 크기를 계산 하여 렌드 트리를 배치
    4. 실제 화면에 렌더트리를 그리기(paint)

    모든 HTML과 CSS가 parsing 된 후 각 단계를 거치는 것이 아니라 parsing된 것부터
    다음 단계를 진행하는 방식을 렌더링 엔진이 제공하기 때문에 사용자가 화면을 빠르게 볼 수 있다.

    *렌더링 최적화
     렌더링은 화면이 바뀔때 reflow, repaint 과정을 거치는데 노드들의 위치나 크기가 변하지 않으면
     reflow 없이 repaint만으로 바뀐 화면을 그린다. 이때 reflow에는 많은 resoruce가 필요하므로
     최적화를 위해서는 reflow가 일어나지 않는 속성값을 사용하여 화면에 변화를 주는 것이 최적화에 효과적이다.
     reflow가 일어나지 않는 속성의 목록은 다음에서 확인 할 수 있다.
     https://csstriggers.com/   

    * 자바스크립트 엔진? 렌더링 엔진?
      자바스크립트 엔진은 자바스크립트 코드를 분석하여 실행하는 엔진
      렌더링 엔진은 브라우저에 요청된 콘텐츠를 표시하는 엔진
인용
https://d2.naver.com/helloworld/59361


2. http, https 통신의 차이?
데이터 암호화의 차이를 가지고 있으며 https는 네트워크 상에서
중간에 제 3자가 정보를 볼 수 없도록 공개키 암호화를 지원한다.

* 공개키/개인키 암호화
 공개키로 암호화를 하면 개인키로만 복호화가 가능하고
 개인키로 암호화하면 공개키로만 복호화할수 있다.    

* HTTPS 동작과정
 인증된 기관(Certificate Authority)에 공개키를 전송하여 인증서를 발급받아 사용.
1. A기업은 HTTP 기반의 애플리케이션에 HTTPS를 적용하기 위해 공개키/개인키를 발급함
2. CA 기업에게 돈을 지불하고, 공개키를 저장하는 인증서의 발급을 요청함
3. CA 기업은 CA기업의 이름, 서버의 공개키, 서버의 정보 등을 기반으로 인증서를 생성하고, CA 기업의 개인키로 암호화하여 A기업에게 이를 제공함
4. A기업은 클라이언트에게 암호화된 인증서를 제공함
5. 브라우저는 CA기업의 공개키를 미리 다운받아 갖고 있어, 암호화된 인증서를 복호화함
6. 암호화된 인증서를 복호화하여 얻은 A기업의 공개키로 데이터를 암호화하여 요청을 전송함
7. 암호화된 인증서는 CA의 개인키로 암호화되었기 때문에, 신뢰성을 확보할 수 있고, 클라이언트는 A 기업의 공개키로 데이터를 암호화하였기 때문에 A기업만 복호화하여 원본의 데이터를 얻을 수 있다.


출처: https://mangkyu.tistory.com/98 [MangKyu's Diary]

3. OOP의 특징?
 객체지향프로그래밍으로 객체의 관점에서 프로그래밍을 하는 것을 의미한다.
 1. 캡슐화
    - 하나의 객체에 대해 그 객체가 특정한 목적을 위해 필요한 변수나 메소드를 하나로 묶는것
    - 정보은닉을 통해 객체의 데이터를 메서드를 통해서만 변경 가능하도록 함
 2. 상속
    - 부모 클래스의 기능을 자식클래스가 사용
 3. 다형성
    - 상속을 통해 기능을 확장, 변경 - 형태가 같지만 다른 기능을 하는 것
    - Overriding: 상속하여 재정의, Overloading : 다른 파라미터를 사용하여 같은이름의 다른 메서드
 4. 추상화
    - 목적과 관련없느 부분을 제거하여 필요한 부분만을 표현하기 위한 개념
    - 객체들의 공통된 특징을 파악해 정의해놓는 것

4. 함수형 프로그래밍
    명령형 프로그래밍 기반으로 개발한 프로그램들이 프로그램의 크기가 커짐에 따라
    코드의 유지보수가 어려워지자 이를 해결하기 위해 나타난 패러다임.
    함수형 프로그래밍은 거의 모든 것을 순수함수로 나누어 문제를 해결하는 기법으로 작은 문제를 해결하기 위한
    함수를 작성하여 가독성을 높이고 유지보수를 용이하기 해준다.
    대입문을 사용하지 않는 프로그래밍.

    -> 부수효과가 없는 순수함수를 1급 객체로 간주하여 파라미터로 넘기거나 반환값으로 사용할 수 있으며,
       참조 투명성을 지킬 수 있다.

    - 부수효과: 변수의값, 자료구조를 수정, 객체의 필드값 설정, 예외나 오류료 실행 중단, 콘솔또는 파일  I/O 발생
    - 순수함수 : 메모리, I/O 관점에서 부수효과가 없고 함수 실행이 외부 영향을 끼치지 않는 함수
    - 1급객체 : 변수나 데이터 구조 안에 담을 수 있고 파라미터로 전달 가능, 반환값으로 사용 가능, 고유한 구별 가능
    - 참조투명성 : 동일한 인자에 대해 항상 동일한 결과 반환, 기존의 값은 변경되지 않고 유지

인용: https://mangkyu.tistory.com/111


5. 웹 프로토콜
    1. 웹 프로토콜이란?
        웹에서 쓰이는 통신규약
    2. HTTP 통신이란?
        Hyper Text Transfer Protocol브라우저가 웹 서버와 통신하기 위해 사용하는 주요 프로토콜
        요청과 응답으로 이루어짐
    3. HTTP1.1 과 2.0의 차이?
        2.0은 여러 리소스를 한번에 받을 수 있고 압축해서 전송받으므로 1.1보다 빠르다.

6. 비동기 프로그래밍
    1. AJAX
        자바스크립트를 이용하여 비동기적으로 서버와 클라이언트가 통신하는 방식
        일반적으로 서버에게 웹페이지를 받아오면 전체 화면을 갱신하지만 AJAX를 이용하면
        필요한 데이터만 HTML, TXT, XML, JSON 형식으로 받아올 수 있다.
    2. Promise 와 CallBack의 차이점, 각각의 장단점 설명
        - CallBack :
            비동기 적으로 호출하는 함수로 어떤 이벤트가 발생하거나 특정 시점에 도달했을 때
            시스템에서 호출하는 함수를 말한다. 특정한 문법적 특징을 가진것이 아니라 호출방식에 의한 구분이다.
            장점- > 비동기적이므로 특정 이벤트가 발생했을 때 원하는 함수를 호출 가능하다.

            비동기 함수로 어떤 함수의 처리 이후 실행되는 함수 
            문법적으로 CallBack에서 return에 대한 처리가 단계적으로 깊어질 수록
            반복된 CallBack함수를 적어야 하므로 알아보기 힘들어지는 단점이 있다.
            이를 해결하기 위해 Proise가 등장.
        - Promise :
            비동기처리에 사용되는 객체로 Callback이 여러개가 중첩될 경우를 극복하기 위한 패턴
            비동기 작업들의 순차적 진행, 병렬적 진행의 컨트롤이 쉬우지고 코드의 가독성을 확보할 수 있다.
    3. Async, Await
        비동기처리를 동기적으로 처리하는 것처럼 보일 수 있는 문법.
        코드가 동기적인 코드 흐름으로 개발이 가능하다.

7. 자바스크립트의 타입
    1. 자바스크립트의 Number Type은 다른 언어들과의 차이점은? 왜 하나만 존재하는지?
        - java의 경우 int, double, float등이 있지만 자바스크립트에는 number로 실수를 지원하므로 하나로 모두 해결가능하다

    2. 자바스크립트의 원시 타입의 종류는?
        - boolean, string, number, udefined, null, symbol 6종류
        - undefined는 선언은 되어있으나 값이 없는 상태 null은 obj이며 빈 값을 의미하며


8. 실행 컨텍스트(Excution Context)
    1. 실행 컨텍스트?
        - 자바스크립트들의 코드들이 실행되기 위한 환경
          전역 컨텍스트, 함수 컨텍스트 2가지로 나뉨
          전역 컨텍스트가 하나 생성 후에 함수가 호출될 때마다 함수 컨텍스트가 생성
          컨텍스트 생성시 변수객체, 스코프체인, this가 생성
          컨텍스트 생성 후 함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 
          스코프체인을 따라 올라가며 찾는다.
          함수 실행이 끝나면 해당 컨텍스트가 사라지고 페이지가 종료 시 전역 컨텍스트 사라짐.
          자바스크립트 코드가 실행되기 위해 필요한 변수객체, 스코프체인, this 정보를 담고 있는 곳을 실행컨텍스트라 함
    2. 자바스크립트의 호이스팅
        - 변수를 선언하고 초기화했을 때 선언부분이 최상단으로 끌어올려지는 현상
    
    3. 클로저(Closure)란? 사용 이유?
        - 반환된 내부함수가 잔신이 선언됐을 때의 환경인 스코프를 기억하여
          자신이 선언됐을 때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수
          자신이 생성될 때의 환경을 기억하는 함수.
          1. 현재 상태를 기억하고 변경된 최신 상태를 유지
          2. 전역 변수의 사용을 억제
          3. 정보 은닉
9. 가비지 컬렉터의 역할과 동작
        메모리 할당을 추적하고 필요하지 않은 영역을 판단하여 회수
        참조 값을 생성하고 더 이상 참조할 것이 없거나 비어졌을 때 동작하여 메모리를 반환한다.

10. 자바스크립트의 순환참조와 문제, 해결방법
        서로 순환되면서 참조되어질 경우 가비지컬렉터가 작동하지 않고 메모리 누수가 발생한다.
        null을 할당하여 연결을 끊는 방법을 사용하여 해결.
        대부분의 브라우저에서는 mark and sweep알고리즘을 사용하여 가비지컬렉터가
        참조되지 않는 객체가 있을 때 동작하는 것이 아니라 접근할 수 없는 객체일때 동작한다.

11. 자바스크립트의 배열이 실제 자료구조 배열이 아닌데 그 이유는?
        자바스크립트 배열은 해시 테이블로 구현된 객체이므로 특정 요소를 탐색하거나
        요소를 삽입 또는 삭제하는 경우 빠른 성능을 기대할 수 있다. 
     

12. 이벤트 루프? 동시성 모델
        자바스크립트는 코드 실행, 이벤트 수집과 처리, 큐에 놓인 하위 작업들을 담당하는 이벤트 루프에 기반한
        동시성 모델을 가지고 있다. 이벤트 발생 시 호출되는 콜백 함수들을 태스크 큐에 전달하고
        콜스택에 쌓여있는 함수가 없을 때 태스크 큐에 쌓인 함수들을 불러와 수행된다.
         
        

13. 프로토 타입?
        모든 객체들이 메소드와 속성들을 상속 받기 위한 템플릿으로서 프로토타입 객체를 가짐.
        생성자 함수가 생성할 모든 인스턴스가 공통적을 ㅗ사용할 프로퍼티나 메소드를 프로토타입에 구현해놓고
        이를 상속하여 사용한다.

    __proto__ 접근자 프로퍼티 : 자신의 프로토타입 내부슬롯에 접근
    프로토타입 체인 : 객체의 프로퍼티에 접근하려고 할 때 객체에 접근하려는 프로퍼티가 없으면
                    __proto__ 접근자 프로퍼티가 가리키는 링크를 따라 부모욕할을 하는 프로토타입의 프로퍼티를 검색
                    최상위는 Object.prototype
    prototype property : 생성자 함수가 생성할 인스턴스의 프로토타입

14. this
    1. This ?
        자바스크립트의 함수는 호출될 때 매개변수로 전달되는 인자값 외에도 arguments 객체와
        this를 암묵적을 전달받는데 this는 함수 호출 방식에 따라 바인딩할 객체가 동적으로 결정된다.
        즉 함수를 선언할 때 this가 정적으로 결정되는 것이 아니라 함수를 호출 할 때 어떻게
        호출되었는가에 따라 this가 동적으로 결정된다.
        함수 호출,내부함수의 경우에는 this가 전역객체에 바인딩되어 window를 가리킨다.
        메소드호출일 경우 메소드를 호출한 객체에 바인딩된다.
        생성자 함수 호출일 경우 생성자 함수 내에 새롭게 생성된 빈 객체를 바인딩한다.
    
    2. Call, Apply, Bind
        this를 특정 객체에 명시적으로 바인딩하는 방법
        Call은 this를 바인딩하면서 함수 호출 두번째 인자가 하나
        Apply는 this를 바인딩하면허 함수 호출 두번째 인자가 배열
        Bind는 함수를 호출하는 것이 아닌 This 가 바인디 된 새로운 함수 리턴

    3. use strict모드에서의 this
        일반함수에서의 this는 undefined가 바인딩

15. ES6
    1. Es6 스펙에 대한 지원이 안될때의 해결방법
        - Babel 사용 Es5이하의 문법으로 변환
        Babel?
        - 트랜스파일러
           이전 버전의 문법으로 재작성 역할을 하는 프로그램
        PolyFill(폴리필)
            이전 버전의 함수를 변경된 표주을 준수할 수 있게 수정하거나 새로 구현한 함수의 스크립트
            ex) ES5 에 없던  Promise, Set, Map 등을 사용한 ES6 코드를 ES5로 바꾸면서 사용 가능한 객체로 만들어줌
    2. Es6에서 추가된 스펙
        let, const, arrowfunction, class, promise...
        var, let,const의 차이점?
        - var: 유연한 변수 선언으로 재선언, 재할당이 가능하므로 사용않는 것을 추천
        - const : 재할당 불가능한 변수
        - let : 재할당 가능한 변수

16. Class 
    자바스크립트도 클래스가 구현 가능하지만
    클래스는 자바스크립트의 프로토타입 기반 패턴의 syntactic sugar이다.

17. 타입스크립트?
    Javscript의 동적타입 언어의 약점을 보완하기 위해 타입을 지정해주는 것
    메모리 절약, 코드의 가독성에 도움

18. 라이브러리와 프레임워크

19. 메소드 체이닝

20. 메모라이제이션

21 Restful API

22. CORS
    교차 출처 리소스 공유(CORS Cross-Origin-Resource-Sharing) 
    웹은 동일 출처 정책을 사용하기 때문에 어떤 출처에서 불러온 문서에서 다른 출처의 리소스를
    불러오는 것을 제한하는데 브라우저에 다른 출처의 리소스를 접근할 수 있는 권한을
    부여해주는 것이 CORS 이다. 도메인, 프로토콜, 포트가 다를 때 CORS HTTP 요청을 실행한다.
    
    - 서버에서 Access-Control-Allow-Origin 헤더와 함께 응답해줘야 한다.
    - 프록시 서버를 사용하면 서버 응답 헤더에 위 헤더를 설정해서 응답해준다.
    - CORS는 브라우저 관련 정책이므로 브라우저를 통하지 않고 서버간 통신으로 해결
    - http-proxy-middleware 라이브러리를 로컬일 때 클라이언트에서 해결
    - 서버에서 직접 세팅
    - 서버 CORS 미들웨어 사용

23. Eslint
    javscript, jsx의 정적분석도구, 코드를 분석해
    문법적인 오류나 안티 패턴을 찾아주고 사용자가 정의한 일관된 코드 스타일에 맞추어
    코드를 작성하도록 도와준다. 최근에 많이 사용중.

24. Prettier
    코드 포맷터. 정해진 코딩 스타일에 따라 작성하도록 도와줌.

25. Webpack
    모듈 번들러, 웹 페이지를 구성하는 html,css,js... 등을 각각 모듈로 보고 이를 조합해서 병합된 결과물을 만듦
    파일 단위의 자바스크립트 모듈관리,
    웹 개발 작업 자동화 도구(web task manager),
    웹 어플리케이션의 빠른 로딩속도와 높은 성능이 필요해지면서 웹팩이 나타남.


26. NPM, Yarn

27. 적응형과 반응형

28. 프로세스와 스레드의 차이

29. CSR과 SSR의 차이

30. 이벤트 관리 방법
    1. 이벤트 등록, 해제
        등록 
        1. inline
            태그 속성으로 지정하는 방법
        2. property
            객체의 프로퍼티로 이벤트를 등록하는 방법
        3. addEventListener() API
        삭제
        removeEventLisetener() API
    2. 이벤트 버블링, 캡쳐링
        부모 요소를 가지고 있는 요소에서 이벤트가 발생되었을 때 브라우저는 두 단계를 실행하는데
        캡쳐링 단계와 버블링 단계이다.
        1. 캡쳐링
            가장 상위의 html부터 이벤트 핸들러가 있는지 확인하고 있으면 실행한다.
            그리고 하위 요소로 이동하고 실제로 선택된 요소에 닿을때 까지 반복

        2. 버블링
            선택된 요소가 이벤트 핸들러를 가지고 있는지 확인하고 실행
            상위 요소로 이동하면서 html 까지 올라가면서 반복
            
        * stopPropagation()을 이용하여 이벤트 전파를 막을 수있다.

    3. 이벤트 위임 방식
        하위 요소 각각에 이벤트를 등록하는 것이 아니라 상위 요소에서 하위 요소의
        이벤트들을 제어하는 방식 버블링이 일어나므로 가능


31. DOM을 건드리는 방식과 아닌 방식들의 차이

32. 반응형 프로그래밍

33. Call by Value , Call by ref

34. null, undefined

35. inline, inline block

36. vue, React

37. 브라우저 저장소?
    * Web Storage : HTML5 부터 제공하는 기능으로 해당 도메인과 관련된 특정 데이터를
                    서버가 아니라 클라이언트 웹브라우저에 저장할 수 있도록 제공하는 기능.
                    쿠키와 비슷한 기능
                    키/값 으로 데이터를 저장하고 키를 기반으로 데이터를 조회
                    LocalStorage(영구저장소), Session Storage(임시저장소)를 따로 두어 데이터의 지속성을 구분
                    쿠키와 마찬가지로 사이트의 도메인 단위로 접근이 제한된다.
                    문자열 기반 데이터 외에 구조화된 객체를 저장할 수 있다.
    1. LocalStorage
        도메인마다 별도로 생성
        명시적으로 지우지 않는 이상 영구적인 보관
        Windows 전역 객체의 LocalStorage 컬렉션을 통해 저장과 조회가 이루어짐

    2. Session Storage
        데이터의 지속성과 엑세스 범위에 특수한 제한이 존재.
        도메인별로 별도로 생성되나 브라우저 컨텍스트 단위로 존재하는지
        Windows 전역 객체의 SessionStorage 컬렉션을 통해 저장과 조회

    3. 쿠키
        웹 사이트에서 쿠키를 설정하면 이후 모든 웹 요청이 서버로 전송되어 트래픽에 영향을 준다.
        용량 제한, 만료일자 지정하므로 기한 제한

    * 세션, 캐시
        1. Session(세션)
            방문자의 요청에 따른 정보를 방문자 메모리가 아니라 웹 서버가 세션아이디 파일을 만들어
            서비스가 돌아가고 있는 서버에 저장한다.
            쿠키에 비해 로그인 정보에 대한 보안이 강하다. 
            서버 메모리를 차지하기 때문에 동시접속자 수가 많을수록 성능 저하의 주요 요인이 된다.
            쿠키는 서버에 요청 시 세션보다 속도가 빠른데 세션은 정보가 서버에 있기 때문이다.
            쿠키는 브라우저가 종료되더라도 저장되어 있을 수 있는 반면 세션은 브라우저 종료시 데이터가 사라진다.
        2. cache(캐시)
            캐시는 이미지나 css,js 파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것이다.

38. Node.js
    브라우저 엔진에서만 사용 가능한 자바스크립트를 데스크탑에서 사용할 수 있게 해주는 런타임환경
    자바스크립트를 이용하고 싱글스레드, 논블로킹 I/O가 특징

39. NPM
    Node Package Manager, 오픈 소스 모듈 패키지 저장소

